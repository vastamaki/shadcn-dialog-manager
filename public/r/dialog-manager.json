{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dialog-manager",
  "type": "registry:component",
  "title": "Dialog Manager",
  "description": "A unified dialog management system for React with ShadCN UI. Define dialog types once in the component, use everywhere with full type safety.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "dialog",
    "button"
  ],
  "files": [
    {
      "path": "registry/default/dialog-manager/lib/dialog-manager/types.ts",
      "content": "import { dialogDefinitions } from \"@/registry/default/dialog-manager/lib/dialog-manager/registry\";\nimport type { ReactNode } from \"react\";\n\nexport interface DialogComponentProps<TProps = unknown, TResult = unknown> {\n  props: TProps;\n  resolve: (result: TResult) => void;\n  reject: (error?: Error) => void;\n  close: () => void;\n}\n\nexport type DialogComponent<TProps = unknown, TResult = unknown> = (\n  props: DialogComponentProps<TProps, TResult>\n) => ReactNode;\n\nexport interface DialogDefinition<TProps = unknown, TResult = unknown> {\n  id: string;\n  component: DialogComponent<TProps, TResult>;\n}\n\nexport type ExtractDialogProps<T> = T extends DialogComponent<infer P, any>\n  ? P extends void\n    ? void\n    : P\n  : never;\n\nexport type ExtractDialogResult<T> = T extends DialogComponent<any, infer R>\n  ? R\n  : never;\n\nexport interface DialogInstance<TProps = unknown, TResult = unknown> {\n  id: string;\n  dialogId: string;\n  component: DialogComponent<TProps, TResult>;\n  props: TProps;\n  resolve: (result: TResult) => void;\n  reject: (error?: Error) => void;\n}\n\nexport type TypedDialogRegistry = Record<string, DialogDefinition<any, any>>;\n\nexport type DialogRegistryType = typeof dialogDefinitions;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/dialog-manager/components/dialog-provider.tsx",
      "content": "\"use client\";\n\nimport {\n  createContext,\n  useCallback,\n  useState,\n  useMemo,\n  type ReactNode,\n} from \"react\";\nimport { dialogDefinitions } from \"@/registry/default/dialog-manager/lib/dialog-manager/registry\";\nimport type {\n  DialogInstance,\n  DialogDefinition,\n  TypedDialogRegistry,\n  ExtractDialogProps,\n  ExtractDialogResult,\n} from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\n\ninterface DialogContextValue<TRegistry extends TypedDialogRegistry = any> {\n  openDialog: <K extends keyof TRegistry>(\n    dialogId: K,\n    ...args: ExtractDialogProps<TRegistry[K][\"component\"]> extends void\n      ? []\n      : [props: ExtractDialogProps<TRegistry[K][\"component\"]>]\n  ) => Promise<ExtractDialogResult<TRegistry[K][\"component\"]>>;\n  closeDialog: (instanceId: string) => void;\n  closeAllDialogs: () => void;\n  registry: Map<string, DialogDefinition>;\n}\n\nexport const DialogContext = createContext<DialogContextValue<any> | null>(\n  null\n);\n\ninterface DialogProviderProps {\n  children: ReactNode;\n}\n\nexport function DialogProvider({ children }: DialogProviderProps) {\n  const [dialogs, setDialogs] = useState<DialogInstance<any, any>[]>([]);\n\n  // Create memoized registry from dialog definitions\n  const registry = useMemo(() => {\n    const map = new Map<string, DialogDefinition<any, any>>();\n\n    for (const [id, definition] of Object.entries(dialogDefinitions)) {\n      if (map.has(id)) {\n        console.warn(\n          `Dialog with id \"${id}\" is already registered. Overwriting.`\n        );\n      }\n      map.set(id, definition as DialogDefinition<any, any>);\n    }\n\n    return map;\n  }, []);\n\n  const openDialog = useCallback(\n    <TProps = void, TResult = unknown>(\n      dialogId: string,\n      props?: TProps\n    ): Promise<TResult> => {\n      return new Promise<TResult>((resolve, reject) => {\n        const dialogDef = registry.get(dialogId);\n\n        if (!dialogDef) {\n          reject(new Error(`Dialog \"${dialogId}\" not found in registry`));\n          return;\n        }\n\n        const instanceId = `${dialogId}-${Date.now()}-${Math.random()}`;\n\n        const instance: DialogInstance<any, any> = {\n          id: instanceId,\n          dialogId,\n          component: dialogDef.component as any,\n          props: props as any,\n          resolve: (result: any) => {\n            setDialogs((prev) => prev.filter((d) => d.id !== instanceId));\n            resolve(result);\n          },\n          reject: (error?: Error) => {\n            setDialogs((prev) => prev.filter((d) => d.id !== instanceId));\n            reject(error || new Error(\"Dialog rejected\"));\n          },\n        };\n\n        setDialogs((prev) => [...prev, instance]);\n      });\n    },\n    [registry]\n  );\n\n  const closeDialog = useCallback((instanceId: string) => {\n    setDialogs((prev) => {\n      const dialog = prev.find((d) => d.id === instanceId);\n      if (dialog) {\n        dialog.reject(new Error(\"Dialog closed manually\"));\n      }\n      return prev.filter((d) => d.id !== instanceId);\n    });\n  }, []);\n\n  const closeAllDialogs = useCallback(() => {\n    setDialogs((prev) => {\n      prev.forEach((dialog) => {\n        dialog.reject(new Error(\"All dialogs closed\"));\n      });\n      return [];\n    });\n  }, []);\n\n  return (\n    <DialogContext.Provider\n      value={{\n        openDialog: openDialog as any,\n        closeDialog,\n        closeAllDialogs,\n        registry,\n      }}\n    >\n      {children}\n      {dialogs.map((dialog) => {\n        const Component = dialog.component;\n        return (\n          <Component\n            key={dialog.id}\n            props={dialog.props}\n            resolve={dialog.resolve}\n            reject={dialog.reject}\n            close={() => closeDialog(dialog.id)}\n          />\n        );\n      })}\n    </DialogContext.Provider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/dialog-manager/lib/dialog-manager/registry.ts",
      "content": "import { ExampleDialog } from \"@/registry/default/dialog-manager/components/example-dialog\";\nimport type { DialogDefinition } from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\n\nexport const dialogDefinitions = {\n  example: {\n    id: \"example\",\n    component: ExampleDialog,\n  },\n} as const satisfies Record<string, DialogDefinition<any, any>>;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/dialog-manager/hooks/use-dialog.ts",
      "content": "import { useContext, useCallback } from \"react\";\nimport { DialogContext } from \"@/registry/default/dialog-manager/components/dialog-provider\";\nimport type {\n  DialogRegistryType,\n  ExtractDialogProps,\n  ExtractDialogResult,\n} from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\n\nexport function useDialog() {\n  const context = useContext(DialogContext);\n\n  if (!context) {\n    throw new Error(\"useDialog must be used within a DialogProvider\");\n  }\n\n  const openDialog = useCallback(\n    async <K extends keyof DialogRegistryType>(\n      dialogId: K,\n      ...args: ExtractDialogProps<\n        DialogRegistryType[K][\"component\"]\n      > extends void\n        ? []\n        : [props: ExtractDialogProps<DialogRegistryType[K][\"component\"]>]\n    ): Promise<ExtractDialogResult<DialogRegistryType[K][\"component\"]>> => {\n      try {\n        return (await context.openDialog(\n          dialogId as string,\n          args[0]\n        )) as ExtractDialogResult<DialogRegistryType[K][\"component\"]>;\n      } catch (error) {\n        console.error(`Failed to open dialog \"${String(dialogId)}\":`, error);\n        throw error;\n      }\n    },\n    [context]\n  );\n\n  const closeDialog = useCallback(\n    (instanceId: string, force = false) => {\n      if (force) {\n        context.closeDialog(instanceId);\n      } else {\n        // Add a small delay to allow for animations\n        setTimeout(() => context.closeDialog(instanceId), 100);\n      }\n    },\n    [context]\n  );\n\n  const closeAllDialogs = useCallback(\n    (force = false) => {\n      if (force) {\n        context.closeAllDialogs();\n      } else {\n        // Add a small delay to allow for animations\n        setTimeout(() => context.closeAllDialogs(), 100);\n      }\n    },\n    [context]\n  );\n\n  return {\n    openDialog,\n    closeDialog,\n    closeAllDialogs,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/default/dialog-manager/components/example-dialog.tsx",
      "content": "import { DialogComponentProps } from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface ExampleDialogProps {\n  title: string;\n  message: string;\n  confirmText?: string;\n  cancelText?: string;\n}\n\nexport function ExampleDialog({\n  props,\n  resolve,\n  close,\n}: DialogComponentProps<ExampleDialogProps, boolean>) {\n  return (\n    <Dialog open onOpenChange={(open) => !open && close()}>\n      <DialogContent>\n        <DialogHeader>\n          <DialogTitle>{props.title}</DialogTitle>\n          <DialogDescription>{props.message}</DialogDescription>\n        </DialogHeader>\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={() => resolve(false)}>\n            {props.cancelText || \"Cancel\"}\n          </Button>\n          <Button variant=\"destructive\" onClick={() => resolve(true)}>\n            {props.confirmText || \"Confirm\"}\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}