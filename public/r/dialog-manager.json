{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dialog-manager",
  "type": "registry:component",
  "title": "Dialog Manager",
  "description": "A unified dialog management system for React with ShadCN UI. Define dialog types once in the component, use everywhere with full type safety.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "dialog",
    "button"
  ],
  "files": [
    {
      "path": "registry/default/dialog-manager/lib/dialog-manager/types.ts",
      "content": "import { dialogDefinitions } from \"@/registry/default/dialog-manager/lib/dialog-manager/registry\";\nimport type { ReactNode } from \"react\";\n\nexport interface DialogComponentProps<TProps = unknown, TResult = unknown> {\n  props: TProps;\n  submit: (result: TResult) => void;\n  cancel: (reason?: string) => void;\n}\n\nexport type DialogComponent<TProps = unknown, TResult = unknown> = (\n  props: DialogComponentProps<TProps, TResult>\n) => ReactNode;\n\nexport interface DialogDefinition<TProps = unknown, TResult = unknown> {\n  id: string;\n  component: DialogComponent<TProps, TResult>;\n}\n\nexport type ExtractDialogProps<T> = T extends DialogComponent<infer P, infer _>\n  ? P extends void\n    ? undefined\n    : P\n  : never;\n\nexport type ExtractDialogResult<T> = T extends DialogComponent<infer _, infer R>\n  ? R\n  : never;\n\nexport interface DialogInstance<TProps = unknown, TResult = unknown> {\n  id: string;\n  dialogId: string;\n  component: DialogComponent<TProps, TResult>;\n  props: TProps;\n  submit: (result: TResult) => void;\n  cancel: (reason?: string) => void;\n}\n\nexport type AnyDialogInstance = DialogInstance<unknown, unknown>;\n\nexport type TypedDialogRegistry = Record<string, DialogDefinition>;\n\nexport type DialogRegistryType = typeof dialogDefinitions;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/dialog-manager/components/dialog-provider.tsx",
      "content": "\"use client\";\n\nimport {\n  createContext,\n  useCallback,\n  useState,\n  useMemo,\n  type ReactNode,\n} from \"react\";\nimport { dialogDefinitions } from \"@/registry/default/dialog-manager/lib/dialog-manager/registry\";\n\nimport type {\n  DialogInstance,\n  AnyDialogInstance,\n  DialogDefinition,\n  DialogComponent,\n  TypedDialogRegistry,\n  ExtractDialogProps,\n  ExtractDialogResult,\n} from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\n\ninterface DialogContextValue<\n  TRegistry extends TypedDialogRegistry = TypedDialogRegistry\n> {\n  openDialog: <K extends keyof TRegistry>(\n    dialogId: K,\n    props?: ExtractDialogProps<TRegistry[K][\"component\"]>\n  ) => Promise<ExtractDialogResult<TRegistry[K][\"component\"]>>;\n\n  registry: Map<string, DialogDefinition>;\n}\n\nexport const DialogContext = createContext<DialogContextValue | null>(null);\n\ninterface DialogProviderProps {\n  children: ReactNode;\n}\n\nexport function DialogProvider({ children }: DialogProviderProps) {\n  const [dialogs, setDialogs] = useState<AnyDialogInstance[]>([]);\n\n  const registry = useMemo(() => {\n    const map = new Map<string, DialogDefinition>();\n\n    for (const [id, definition] of Object.entries(dialogDefinitions)) {\n      if (map.has(id)) {\n        console.warn(\n          `Dialog with id \"${id}\" is already registered. Overwriting.`\n        );\n      }\n      map.set(id, definition as unknown as DialogDefinition);\n    }\n\n    return map;\n  }, []);\n\n  const openDialog = useCallback(\n    <TProps, TResult = unknown>(\n      dialogId: string,\n      props?: TProps\n    ): Promise<TResult> => {\n      return new Promise<TResult>((resolve, reject) => {\n        const dialogDef = registry.get(dialogId);\n\n        if (!dialogDef) {\n          reject(new Error(`Dialog \"${dialogId}\" not found in registry`));\n          return;\n        }\n\n        const instanceId = `${dialogId}-${Date.now()}-${Math.random()}`;\n\n        const submitHandler = (result: TResult) => {\n          setDialogs((prev) => prev.filter((d) => d.id !== instanceId));\n          resolve(result);\n        };\n\n        const cancelHandler = (reason?: string) => {\n          setDialogs((prev) => prev.filter((d) => d.id !== instanceId));\n          reject(new Error(reason || \"Dialog cancelled\"));\n        };\n\n        const instance: DialogInstance<TProps, TResult> = {\n          id: instanceId,\n          dialogId,\n          component: dialogDef.component as DialogComponent<TProps, TResult>,\n          props: props as TProps,\n          submit: submitHandler,\n          cancel: cancelHandler,\n        };\n\n        setDialogs((prev) => {\n          const existingDialog = prev.find((d) => d.dialogId === dialogId);\n          if (existingDialog) {\n            reject(new Error(`Dialog \"${dialogId}\" is already open`));\n            return prev;\n          }\n\n          return [...prev, instance as AnyDialogInstance];\n        });\n      });\n    },\n    [registry]\n  );\n\n  const contextValue = useMemo(\n    () => ({\n      openDialog,\n      registry,\n    }),\n    [openDialog, registry]\n  );\n\n  const renderedDialogs = useMemo(\n    () =>\n      dialogs.map((dialog) => {\n        const DialogComponent = dialog.component;\n        return (\n          <DialogComponent\n            key={dialog.id}\n            props={dialog.props}\n            submit={dialog.submit}\n            cancel={dialog.cancel}\n          />\n        );\n      }),\n    [dialogs]\n  );\n\n  return (\n    <DialogContext.Provider value={contextValue}>\n      {children}\n      {renderedDialogs}\n    </DialogContext.Provider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/dialog-manager/lib/dialog-manager/registry.ts",
      "content": "// Import your dialogs here\n// import { ExampleDialog } from \"../../components/example-dialog\";\n\nexport const dialogDefinitions = {\n  // example: {\n  //   id: \"example\",\n  //   component: ExampleDialog,\n  // },\n} as const;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/dialog-manager/hooks/use-dialog.ts",
      "content": "import { useContext } from \"react\";\nimport { DialogContext } from \"@/registry/default/dialog-manager/components/dialog-provider\";\nimport type {\n  DialogRegistryType,\n  ExtractDialogProps,\n  ExtractDialogResult,\n} from \"@/registry/default/dialog-manager/lib/dialog-manager/types\";\n\nexport function useDialog() {\n  const context = useContext(DialogContext);\n\n  if (!context) {\n    throw new Error(\"useDialog must be used within a DialogProvider\");\n  }\n\n  const openDialog = <K extends keyof DialogRegistryType>(\n    dialogId: K,\n    props?: ExtractDialogProps<DialogRegistryType[K][\"component\"]>\n  ): Promise<ExtractDialogResult<DialogRegistryType[K][\"component\"]>> => {\n    return context.openDialog(dialogId as string, props) as Promise<\n      ExtractDialogResult<DialogRegistryType[K][\"component\"]>\n    >;\n  };\n\n  return {\n    openDialog,\n    registry: context.registry,\n  };\n}\n",
      "type": "registry:hook"
    }
  ]
}